[翻訳元](https://overreacted.io/what-are-the-react-team-principles/)

# What Are the React Team Principles?(Reactチームの原則)

Reactチームにいる間、ジョーダン、セバスチャン、ソフィー、その他のチームメンバーがどのように問題に取り組んでいるかを見ることができて幸運でした。
この投稿では、彼らから学んだことをいくつかの高レベルの技術原則にまとめています。
これは、Reactチームの運営方法に関する観察結果を形式化するための私の個人的な試みです。
他のチームメンバーは異なる視点を持っているかもしれません。

## API前のUIについて

大規模に展開すると、すべての抽象化には独自の癖があります。
これらの癖は、ユーザーインターフェイスにどのように現れますか？

抽象化はユーザーエクスペリエンスに直接影響を与えます。
これが、APIを設計する際に、抽象化そのものから始めるのではなく、抽象化したいユーザー体験から始め、抽象化したものから逆算していく理由です。
望まれるユーザー体験から始め、抽象化に遡って作業を進めていきます。

逆方向に作業するときに、適切なユーザーエクスペリエンスを実現するために、アプローチ全体を変更する必要があることに気付くことがあります。
 APIから始めた場合、それはわかりません。そのため、APIよりもUIを優先します。
 
## 複雑さを吸収する
 
Reactの内部をシンプルにすることは目標ではありません。
製品開発者がコードを理解し、変更しやすくするために、Reactの内部を複雑にすることをいとわない。 

私たちは、製品開発を分散化して協調的に行えるようにしたいと考えています。
多くの場合、それは私たちが中央集権化の矢面に立つことを意味します。
Reactは、その仕事をするために何かがコーディネーターとして機能する必要があるため、
小さな単純な疎結合モジュールに分割することはできません。それがReactです。

抽象度を上げることで、製品開発者はよりパワフルに開発できます。
開発者は、システム全体がある種の予測可能な特性を持っていることから利益を得ることができます。
しかし、これは私たちが導入するN+1番目の新しい機能はすべて、N個の既存の機能のすべてとうまく動作しなければならないことを意味します。
これが、Reactに新しい機能を貢献することが、設計と実装の両方の面で非常に難しい理由です。
これが、多くの「コア」オープンソースの貢献を得られない理由です。

私たちは複雑さを吸収して、製品コードへの流出を阻止しています。

## 熟語をハックする？

すべての API は新たな制限を生み出します。
時には、これらの制限がユーザーが楽しいユーザー体験を提供することを妨げてしまうこともあります。
私たちは、必要に応じて私たちの周りで作業できるようにエスケープハッチを提供しています。

ハックは壊れやすいので、長くは生き残れません。
製品開発者は、ハックをサポートすることでメンテナンスの打撃を受けることを好むのか、ユーザーエクスペリエンスを低下させるがハックは削除するのかを選択しなければなりません。
多くの場合、ユーザー・エクスペリエンスは失われ、ハックによって以下のような改善が妨げられることになります。

私たちはエスケープハッチを使ったハッキングを許可し、人々がどのハッキングを実践しているかを観察する必要があります。
私たちの仕事は、最終的には、より良いユーザーエクスペリエンスの名の下に存在するハックのための慣用的な解決策を提供することです。
時には、解決には何年もかかるかもしれません。私たちは、下手な慣用句を定着させるよりも、柔軟性のあるハックを好む。

## ローカル推論を有効にする

コードエディタでできることはあまり多くありません。
いくつかの行を追加したり、削除することができます。あるいは何かをコピーして貼り付けることもできます。
しかし、多くの抽象化がこれらの基本的な操作を困難にしています。

例えば、MVC フレームワークでは、レンダリング出力の一部を削除することは安全ではないという傾向があります。
これは、親が子のメソッドを強制的に呼び出してしまうからです（削除した後には存在しない）。
対照的にReact では、通常はレンダーツリーのコードを削除するだけで安全です。これは勝利です。

APIを設計する際には、その人が作業しているコードについてのローカルな知識しか持っていないことを想定しています。
意図した効果が局所的なものである場合、予期せぬ結果を防ぎたいと考えています。
例えば、コードを追加しても安全であることを期待します。
コードの削除や変更は、この変更の一部として考慮される必要があるコード全体の軌跡を明確に指し示すことを期待しています。
一つのファイルを変更するときに、コードベース全体の知識を想定することはできません。

何かを行うことが安全でない場合、開発者にはできるだけ早く変更の影響を完全に把握してもらいたいものです。
警告、型チェック、開発者向けのツールが役立ちますが、API の設計によって制限されます。API が十分に制限されていない場合、ローカルでの推論は不可能です。
例えば、これが findDOMNode() がダメな理由です。グローバルな知識を必要とします。

## 積極的に複雑にする?

フレームワークの中には、道に分かれ道があることを選ぶものがあります。簡単な方法と強力な方法です。
簡単な方法は学ぶのはいいことですが、ある時点で壁にぶつかります。
そんなときは、過去の作業を元に戻して、別の方法で再実装しなければなりません。

私たちは、複雑なものを実装する場合でも、単純なものを実装する場合とあまり構造が変わらないことを好んでいます。例えば、私たちは「単純なケースのための」別個のテンプレートDSLを提供しません。いずれにせよ、すぐにでも完全な機能を備えたメカニズムが必要になると思うのであれば、私たちは参入障壁について妥協しても構わないと考えています。

時には、「簡単な方法」と「強力な方法」は2つの異なるフレームワークです。
そうなると、書き換えも必要になってきます。それも避けられるといいですね。
例えば、サーバーレンダリングを追加することは、Reactでは多少の努力が必要な最適化ですが、完全なリライトは必要ありません。